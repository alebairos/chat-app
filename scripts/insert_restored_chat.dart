import 'dart:io';
import 'dart:convert';
import 'package:isar/isar.dart';
import 'package:path_provider/path_provider.dart';
import 'package:ai_personas_app/models/chat_message_model.dart';
import 'package:ai_personas_app/models/message_type.dart';

/// Insert parsed chat data into Isar database
/// Uses the JSON data generated by restore_chat_simple.dart
Future<void> main(List<String> args) async {
  final jsonFile =
      args.isNotEmpty ? args[0] : 'docs/exports/restoration_data.json';
  final clearFirst = args.contains('--clear-first');

  print('ğŸ”„ Starting database insertion...');
  print('ğŸ“ JSON file: $jsonFile');
  if (clearFirst) print('âš ï¸  Will clear existing messages first');

  try {
    final inserter = ChatDatabaseInserter();
    await inserter.insertFromJson(jsonFile, clearFirst: clearFirst);

    print('âœ… Database insertion complete!');
  } catch (e) {
    print('âŒ Insertion failed: $e');
    exit(1);
  }
}

class ChatDatabaseInserter {
  Future<void> insertFromJson(String jsonFilePath,
      {bool clearFirst = false}) async {
    // Read JSON data
    final file = File(jsonFilePath);
    if (!await file.exists()) {
      throw Exception('JSON file not found: $jsonFilePath');
    }

    final content = await file.readAsString();
    final data = json.decode(content) as Map<String, dynamic>;
    final messagesData = data['messages'] as List<dynamic>;

    print('ğŸ“Š Loading ${messagesData.length} messages from JSON');

    // Convert to ChatMessageModel objects
    final messages = <ChatMessageModel>[];
    for (final messageData in messagesData) {
      final message = _createChatMessage(messageData as Map<String, dynamic>);
      messages.add(message);
    }

    print('âœ… Converted to ${messages.length} ChatMessageModel objects');

    // Initialize Isar database
    final dir = await getApplicationDocumentsDirectory();
    final isar = await Isar.open(
      [ChatMessageModelSchema],
      directory: dir.path,
    );

    print('ğŸ“± Connected to Isar database at: ${dir.path}');

    try {
      // Clear existing messages if requested
      if (clearFirst) {
        print('ğŸ—‘ï¸  Clearing existing messages...');
        await isar.writeTxn(() async {
          await isar.chatMessageModels.clear();
        });
        print('âœ… Existing messages cleared');
      }

      // Insert messages in batches
      print('ğŸ’¾ Inserting messages into database...');
      const batchSize = 50;
      for (int i = 0; i < messages.length; i += batchSize) {
        final batch = messages.skip(i).take(batchSize).toList();

        await isar.writeTxn(() async {
          await isar.chatMessageModels.putAll(batch);
        });

        print(
            '   ğŸ’¾ Inserted batch ${(i / batchSize).floor() + 1}/${(messages.length / batchSize).ceil()}');
      }

      print('âœ… Inserted ${messages.length} messages successfully');

      // Verify insertion
      await _verifyInsertion(isar, messages.length);
    } finally {
      await isar.close();
    }
  }

  ChatMessageModel _createChatMessage(Map<String, dynamic> data) {
    return ChatMessageModel(
      text: data['text'] as String,
      isUser: data['isUser'] as bool,
      type: data['type'] == 'audio' ? MessageType.audio : MessageType.text,
      timestamp: DateTime.parse(data['timestamp'] as String),
      mediaPath: data['mediaPath'] as String?,
      personaKey: data['personaKey'] as String?,
      personaDisplayName: data['personaDisplayName'] as String?,
    );
  }

  Future<void> _verifyInsertion(Isar isar, int expectedCount) async {
    print('ğŸ” Verifying insertion...');

    final actualCount = await isar.chatMessageModels.count();
    print('âœ… Database contains $actualCount messages');

    if (actualCount != expectedCount) {
      print(
          'âš ï¸  Warning: Expected $expectedCount but found $actualCount messages');
    }

    // Check message distribution
    final userCount =
        await isar.chatMessageModels.filter().isUserEqualTo(true).count();
    final aiCount =
        await isar.chatMessageModels.filter().isUserEqualTo(false).count();

    print('âœ… Message distribution:');
    print('   ğŸ“ User messages: $userCount');
    print('   ğŸ¤– AI messages: $aiCount');

    // Check personas
    final personas = await isar.chatMessageModels
        .filter()
        .isUserEqualTo(false)
        .distinctByPersonaDisplayName()
        .findAll();

    if (personas.isNotEmpty) {
      print('âœ… Personas found:');
      for (final message in personas) {
        final persona = message.personaDisplayName ?? 'Unknown';
        final count = await isar.chatMessageModels
            .filter()
            .personaDisplayNameEqualTo(persona)
            .count();
        print('   â€¢ $persona: $count messages');
      }
    }

    // Check time range
    final oldest =
        await isar.chatMessageModels.where().sortByTimestamp().findFirst();
    final newest =
        await isar.chatMessageModels.where().sortByTimestampDesc().findFirst();

    if (oldest != null && newest != null) {
      print('âœ… Time range: ${oldest.timestamp} to ${newest.timestamp}');
    }

    print('âœ… Verification complete');
  }
}
