import 'dart:convert';
import 'dart:io';
import '../utils/logger.dart';
import '../config/character_config_manager.dart';

/// Oracle JSON Loader (FT-062)
///
/// Loads preprocessed Oracle activity data from JSON files
/// generated by scripts/preprocess_oracle.py
class OracleActivityParser {
  static final Logger _logger = Logger();
  static OracleParseResult? _cachedResult;
  static String? _lastPersonaKey;

  /// Load Oracle activities from preprocessed JSON
  static Future<OracleParseResult> parseFromPersona() async {
    try {
      final configManager = CharacterConfigManager();
      final oracleConfigPath = await configManager.getOracleConfigPath();

      if (oracleConfigPath == null) {
        _logger.debug('No Oracle config for current persona');
        return OracleParseResult.empty();
      }

      // Check cache
      final personaKey = configManager.activePersonaKey;
      if (_cachedResult != null && _lastPersonaKey == personaKey) {
        _logger.debug('Using cached Oracle data for persona: $personaKey');
        return _cachedResult!;
      }

      // Load from JSON
      final jsonPath = oracleConfigPath.replaceAll('.md', '.json');
      final result = await _loadFromJSON(jsonPath);

      // Cache result
      _cachedResult = result;
      _lastPersonaKey = personaKey;

      _logger.info(
          'Successfully loaded Oracle: ${result.dimensions.length} dimensions, ${result.totalCount} total activities');
      return result;
    } catch (e) {
      _logger.error('Error loading Oracle config: $e');
      return OracleParseResult.empty();
    }
  }

  static Future<OracleParseResult> _loadFromJSON(String jsonPath) async {
    final file = File(jsonPath);

    if (!await file.exists()) {
      _logger.warning('Oracle JSON file not found: $jsonPath');
      _logger.info(
          'Hint: Run "python3 scripts/preprocess_oracle.py --all" to generate JSON files');
      return OracleParseResult.empty();
    }

    try {
      final jsonContent = await file.readAsString();
      final data = jsonDecode(jsonContent) as Map<String, dynamic>;

      // Parse dimensions
      final dimensionsData = data['dimensions'] as Map<String, dynamic>? ?? {};
      final dimensions = <String, DimensionDefinition>{};

      dimensionsData.forEach((key, value) {
        final dimData = value as Map<String, dynamic>;
        dimensions[key] = DimensionDefinition(
          id: dimData['id'] as String,
          code: dimData['code'] as String,
          fullName: dimData['name'] as String,
          displayName: dimData['display_name'] as String,
        );
      });

      // Parse activities
      final activitiesData = data['activities'] as Map<String, dynamic>? ?? {};
      final activities = <String, ActivityDefinition>{};

      activitiesData.forEach((key, value) {
        final actData = value as Map<String, dynamic>;
        activities[key] = ActivityDefinition(
          code: actData['code'] as String,
          name: actData['name'] as String,
          dimension: actData['dimension'] as String,
          source: actData['source'] as String? ?? 'json',
        );
      });

      return OracleParseResult(
        dimensions: dimensions,
        activities: activities,
      );
    } catch (e) {
      _logger.error('Failed to parse Oracle JSON: $e');
      return OracleParseResult.empty();
    }
  }

  /// Clear cache when persona changes
  static void clearCache() {
    _cachedResult = null;
    _lastPersonaKey = null;
    _logger.debug('Oracle cache cleared');
  }
}

/// Data models preserved for FT-062 compatibility
class OracleParseResult {
  final Map<String, DimensionDefinition> dimensions;
  final Map<String, ActivityDefinition> activities;

  const OracleParseResult({
    required this.dimensions,
    required this.activities,
  });

  static OracleParseResult empty() => const OracleParseResult(
        dimensions: {},
        activities: {},
      );

  int get totalCount => activities.length;
  int get libraryCount => activities.length;
  int get trilhaCount => 0;
  bool get isNotEmpty => activities.isNotEmpty;
  bool get isEmpty => activities.isEmpty;
  String get sourceFileName => 'oracle_prompt_2.1.md';
}

class DimensionDefinition {
  final String id;
  final String code;
  final String fullName;
  final String displayName;

  const DimensionDefinition({
    required this.id,
    required this.code,
    required this.fullName,
    required this.displayName,
  });
}

class ActivityDefinition {
  final String code;
  final String name;
  final String dimension;
  final String source;

  const ActivityDefinition({
    required this.code,
    required this.name,
    required this.dimension,
    required this.source,
  });
}
